# Card Management System(SafeCard)
#### Name : Aarchi Mann
#### email : aarchi.mann@sydney.edu.au

Card Management is a Spring Boot application that uses Firestore-backed database along with Google KMS for security.

## Getting Started

> **Heads up:** The application expects Google Cloud credentials so it can decrypt the encrypted service-account file and talk to Firestore/KMS.
### Step 1 
#### Install the Google Cloud CLI(If not done already)
- **For macOS**
  1. Ensure Homebrew is installed (`/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"`).
  2. Install the SDK: `brew install --cask google-cloud-sdk`.
  3. Restart your terminal so the `gcloud` binary is on the PATH.
- **For Windows**
  1. Download the installer from the [Google Cloud SDK page](https://cloud.google.com/sdk/docs/install), if not already installed.
  2. Run `GoogleCloudSDKInstaller.exe` and keep the default options to add `gcloud` to your PATH.
  3. Open a new PowerShell session after the installer completes.

### Step 2
#### Authenticate with Google Cloud(for CLI to be authenticated)
- **For macOS (Terminal)**: `gcloud auth application-default login`
- **For Windows (PowerShell)**: `gcloud auth application-default login`

### Step 3
#### Run the Application
```bash
./gradlew bootRun
```
On startup the Gradle task opens `http://localhost:8080` automatically.

### Run Tests
```bash
./gradlew test
```
Simple WebMvc slice test, asserts the card creation and search endpoint returns the expected responses.
You can find the result html file in `build/reports/tests/test/index.html`

## Brief Database Description & Reasoning
- **Chosen DB:** Google Firestore (NoSQL).
- **Reasoning:** I chose Firestore because it scales cleanly from a solo project to a full team: one managed, highly available datastore with minimal local setup and no per-developer DB installs. Since I planned to use Cloud KMS, I already had a GCP project and could keep key handling simple—the service-account JSON is encrypted with KMS and decrypted at runtime, so no plaintext secrets are committed; after a one-time gcloud auth application-default login, ./gradlew bootRun is enough to start the app. Firestore and KMS use Google IAM, so If i want i can grant least-privilege roles per environment (e.g., “Firestore User,” “KMS CryptoKey Decrypter”), rotate access centrally without code changes.         
Compared to MySQL/Postgres, this avoids Docker/server setup, migrations, and credential rotation for every collaborator; compared to H2, it provides shared, persistent storage with production-like security and behavior. If the project grows, Firestore lets the team onboard quickly while keeping operations light.

### Note 
A card holder : 'Test User' , with PAN : 1234 1234 1234 1234 , has already been inputted into the database, for test purposes.


## Architecture Overview/Process
- **Prototype**: [Figma design](https://www.figma.com/design/IUmM4cdMf6xA9HQIMw1ZAv/Card_management?node-id=0-1&t=1cB3sJ1r70qxiB0M-1) guided the UI layout for the project.
- **Frontend**: Static HTML/JavaScript stored in `src/main/resources/static`.
- **Backend**: Spring Boot (Java 17).
- **Database**: Google Firestore.

## Database Structure & Security Strategy
Firestore stores card records in the `cards` collection. Each document follows the structure below:

| Field            | Type     | Description                                                                                  |
|------------------|----------|----------------------------------------------------------------------------------------------|
| `id`             | string   | Firestore document identifier (UUID generated by Firestore itself).                          |
| `cardholderName` | string   | Cardholder name.                                                                             |
| `panCiphertext`  | string   | Base64-encoded ciphertext of the full PAN encrypted with Google Cloud KMS.                   |
| `lastFourHash`   | string   | SHA-256 hash of the final four digits, used for equality searches without decrypting the PAN.|
| `createdAt`      | instant  | Timestamp captured when the card is persisted.                                               |

**Why two fields (`panCiphertext`, `lastFourHash`)?**
- Encrypting the full PAN prevents accidental leaks if the database is compromised.
- Hashing the last four digits allows equality searches (`/api/cards?last4=1234`) without exposing PAN data or requiring decryption keys on the API server.
- Google Cloud KMS manages encryption keys so the application never stores long-lived secrets.

## API Endpoints

| Method | Endpoint            |
|--------|---------------------|
| POST   | `/api/cards`        | 
| GET    | `/api/cards`        | 
| GET    | `/api/cards/search` | 
